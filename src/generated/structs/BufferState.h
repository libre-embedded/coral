/**
 * \file
 * \brief Generated by ifgen (4.7.3).
 */

#pragma once
#ifndef CORAL_STRUCTS_BUFFERSTATE_H
#define CORAL_STRUCTS_BUFFERSTATE_H

#include "../ifgen/common.h"

namespace Coral
{

struct [[gnu::packed]] BufferState
{
    /* Constant attributes. */
    static constexpr struct_id_t id = 1; /*!< BufferState's identifier. */
    static constexpr std::size_t size =
        16; /*!< BufferState's size in bytes. */

    /* Fields. */
    uint32_t write_cursor;
    uint32_t read_cursor;
    uint32_t read_count;
    uint32_t write_count;

    /* Methods. */
    using Buffer = byte_array<size>;
    using Span = byte_span<size>;

    auto operator<=>(const BufferState &) const = default;

    /**
     * Get this instance as a fixed-size byte array.
     */
    inline Buffer *raw()
    {
        return reinterpret_cast<Buffer *>(this);
    }

    /**
     * Get this instance as a byte span.
     */
    inline Span span()
    {
        return Span(*raw());
    }

    /**
     * Get this instance as a read-only fixed-size byte array.
     */
    inline const Buffer *raw_ro() const
    {
        return reinterpret_cast<const Buffer *>(this);
    }

    /**
     * Handle swapping bytes for endian conversion (native).
     *
     * \tparam endianness Byte order for encoding elements.
     */
    template <std::endian endianness = default_endian>
    inline void endian(void)
        requires(endianness == std::endian::native)
    {
    }

    /**
     * Handle swapping bytes for endian conversion (swap required).
     *
     * \tparam endianness Byte order for encoding elements.
     */
    template <std::endian endianness = default_endian>
    inline void endian(void)
        requires(endianness != std::endian::native)
    {
        write_cursor = handle_endian<endianness>(write_cursor);
        read_cursor = handle_endian<endianness>(read_cursor);
        read_count = handle_endian<endianness>(read_count);
        write_count = handle_endian<endianness>(write_count);
    }

    /**
     * Encode this instance to a buffer.
     *
     * \tparam     endianness Byte order for encoding elements.
     * \param[out] buffer     Buffer to write.
     * \return                The number of bytes encoded.
     */
    template <std::endian endianness = default_endian>
    inline std::size_t encode(Buffer *buffer) const
    {
        *buffer = *raw_ro();

        reinterpret_cast<BufferState *>(buffer)->endian<endianness>();

        return size;
    }

    /**
     * Update this instance from a buffer.
     *
     * \tparam    endianness Byte order from decoding elements.
     * \param[in] buffer     Buffer to read.
     * \return               The number of bytes decoded.
     */
    template <std::endian endianness = default_endian>
    inline std::size_t decode(const Buffer *buffer)
    {
        *raw() = *buffer;

        endian<endianness>();

        return size;
    }
};

static_assert(sizeof(BufferState) == BufferState::size);
static_assert(ifgen_struct<BufferState>);

}; // namespace Coral

#endif
