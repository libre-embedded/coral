/**
 * \file
 * \brief Generated by ifgen (4.2.2).
 */

#pragma once

#include "../ifgen/common.h"

namespace Coral
{

struct [[gnu::packed]] BufferState
{
    /* Constant attributes. */
    static constexpr struct_id_t id = 1; /*!< BufferState's identifier. */
    static constexpr std::size_t size =
        16; /*!< BufferState's size in bytes. */

    /* Fields. */
    uint32_t write_cursor;
    uint32_t read_cursor;
    uint32_t read_count;
    uint32_t write_count;

    /* Methods. */
    using Buffer = byte_array<size>;
    using Span = byte_span<size>;

    auto operator<=>(const BufferState &) const = default;

    /**
     * Get this instance as a fixed-size byte array.
     */
    inline Buffer *raw()
    {
        return reinterpret_cast<Buffer *>(this);
    }

    /**
     * Get this instance as a byte span.
     */
    inline Span span()
    {
        return Span(*raw());
    }

    /**
     * Get this instance as a read-only fixed-size byte array.
     */
    inline const Buffer *raw_ro() const
    {
        return reinterpret_cast<const Buffer *>(this);
    }

    /**
     * Encode this instance to a buffer.
     *
     * \tparam     endianness Byte order for encoding elements.
     * \param[out] buffer     Buffer to write.
     * \return                The number of bytes encoded.
     */
    template <std::endian endianness = default_endian>
    inline std::size_t encode(Buffer *buffer) const
    {
        /* Check if buffer is external. */
        auto this_ro = raw_ro();
        if (buffer != this_ro)
        {
            *buffer = *this_ro;
        }

        /* Handle byte swapping if necessary. */
        if (endianness != std::endian::native)
        {
            auto other = reinterpret_cast<BufferState *>(buffer);
            (void)other;
            other->write_cursor =
                handle_endian<uint32_t, endianness>(other->write_cursor);
            other->read_cursor =
                handle_endian<uint32_t, endianness>(other->read_cursor);
            other->read_count =
                handle_endian<uint32_t, endianness>(other->read_count);
            other->write_count =
                handle_endian<uint32_t, endianness>(other->write_count);
        }

        return size;
    }

    /**
     * Update this instance from a buffer.
     *
     * \tparam    endianness Byte order from decoding elements.
     * \param[in] buffer     Buffer to read.
     * \return               The number of bytes decoded.
     */
    template <std::endian endianness = default_endian>
    inline std::size_t decode(const Buffer *buffer)
    {
        /* Check if buffer is external. */
        auto this_raw = raw();
        if (this_raw != buffer)
        {
            *this_raw = *buffer;
        }

        /* Handle byte swapping if necessary. */
        if (endianness != std::endian::native)
        {
            write_cursor = handle_endian<uint32_t, endianness>(write_cursor);
            read_cursor = handle_endian<uint32_t, endianness>(read_cursor);
            read_count = handle_endian<uint32_t, endianness>(read_count);
            write_count = handle_endian<uint32_t, endianness>(write_count);
        }

        return size;
    }
};

static_assert(sizeof(BufferState) == BufferState::size);

/* Stream interfaces. */
inline byte_istream &operator>>(byte_istream &stream, BufferState &instance)
{
    stream.read(instance.raw()->data(), BufferState::size);
    return stream;
}
inline byte_ostream &operator<<(byte_ostream &stream,
                                const BufferState &instance)
{
    stream.write(instance.raw_ro()->data(), BufferState::size);
    return stream;
}

}; // namespace Coral
